# Projet_systeme_exploitation_g6
Voici notre projet réaliser par Julie PRIGENT et Dorine HENRY (étudiante en L3 informatique parcours MIAGE).


Nous avons créé trois fichiers qui sont normalement relier entre elle (sys_taches.py, para_maximal.py et main.py).
main.py => ce sera dans le main que vous trouverez notre class Task où vous pourrez modifier la liste des tâches afin de personnaliser et de tester notre code avec d'autres exemples.
sys_taches.py => dans ce fichier vous trouverez la class TaskSystem où il y a aura tout les fonction demandé (la validation des entrées, un jeu de données randomnisé, run, runSeq)
para_maximal.py => dans ce fichier vous y trouverez la partie sur le parallélisme maximal 

Si jamais le programme séparé ne fonctionne pas, vous aurez le fichier tout_fct.py qui comporte tout notre code du projet.

1/ Librairies utilisées à importer en début de projet : 
Afin de permettre la bonne exécution des différentes fonctions quelques librairies doivent être installées dont voici les noms : 

Nom de la librairie
intérêt
threading
Générer une exécution parallèle du système de tâche
random
Permettre la simulation de variables aléatoires pour le test randomisé du déterminisme
time
Enregistrer la durée d’exécution et laisser le temps à une tâche de s’exécuter
graphviz 
Afficher le graphe représentant le système de tâches


Méthode d’importation : import nom_librairie 
Exemple des librairies importées ci-dessous 
import threading
import random
import time
import graphviz

2/ Déclaration des tâches
La déclaration des tâches se réalise en créant un objet de la classe Task sous la forme suivante :  T1 = Task(name, reads, writes, func) 

Où les arguments ont les significations suivantes : 

nom_tache = le nom de la tâche, doit être une chaîne de caractère, exemple : “T1”
reads = correspond au domaine de lecture de la tâche, soit des variables que la tâche va être amené à lire le contenu lors de son exécution, exemple de déclaration : [“A”, “B”, “C]
writes = correspond au domaine de lecture de la tâche, qui correspond aux variables dans lesquelles il y aura écriture lors de l’éxecution de la tâches, exemple de déclaration : [“D”]
func = correspond à l’action réalisé par la tâche, exemple de déclaration : A + B 
2e exemple de déclaration : print(“Réalisation de la tâche 2”). Afin de générer un affichage il faut que l’utilisateur indique print() autour de ce qu’il souhaite réaliser

Voici un exemple de déclaration complète d’objet Task : 
T1 = Task("T1", ["A", "B"] , ["C"], lambda: print("exécution tache T1"))

3/Construction du système de tâches 

Une fois les tâches que l’on souhaite voir dans notre système de tâche créés, on peut déclarer un système de tâche en créant un objet de la classe TaskSystem qui prend la forme suivante : 

nom_systeme_de_tache = TaskSystem(taches, dictPrec)

Dont les arguments ont les significations suivantes : 
taches : correspond à la liste des objets Task qui sont concernés par le système, exemple de déclaration : [T1, T3, T4], le système comprendra les 3 objets Task déclarés
dictPrec : correspond au dictionnaire des précédences de tout le système de tâches, on déclare un dictionnaire python avec chaque instance comme suit : 
T2 : [T1] la tâche T2 doit attendre que T1 soit terminé pour se lancer

Ainsi voici un exemple de déclaration complet : {T1 : [], T4 : [T1], T3 : [T1]} pour le graphe : 

Voici un exemple de déclaration d’objet TaskSystem appelé s1 : 
s1 = TaskSystem([T1, T2, T3, T4, T5, T6], {T1: [], T2: [T1], T3: [T1],T4: [T2, T3], T5: [T3], T6: [T4, T5]})



4/ Lancement de l’algorithme de parallélisation maximale 
L’algorithme de parallélisation maximale est lancé lors de l’appel de la fonction getDependancies(TaskSystem, Task) celle-ci renvoi les dépendances de la tâche inscrite en deuxième argument et modifie le dictionnaire de précédence de l’objet TaskSystem automatiquement 
5/ Exécution du système de tâche en séquentiel 
Lancement de la fonction runSeq() sur un objet TaskSystem : nom_systeme.runSeq(), chaque tâche s’exécute alors en réalisant les instructions inscrites en argument “func”, le tout séquentiellement
6/ Exécution du système de tâche en parallèle 
Lancement de la fonction run() sur un objet TaskSystem : nom_systeme.run(), chaque tâche s’exécute alors en réalisant les instructions inscrites en argument “func”, le tout parallèlement si possible. 
(cette fonctionne ne fonctionne pas, elle créer une boucle infinie. Je pense que c’est à cause d’un mauvais verrouillage de la valeur de la première tâche.)
7/ Test randomisé du déterminisme 
Lancement de la fonction detTestRand() sur un objet TaskSystem tel que : nom_systeme.defTestRand()
La fonction renvoi un message indiquant si le système de tâche et déterminé ou non à la suite de ce test

8/ Affichage du graphe 

Lancement de la fonction draw() en mettant en argument un système de tache : draw(nom_systeme) 
Renvoi un graphe représenté graphiquement grâce à la librairie Graphviz, exemple : 



from .main import Task
import graphviz
#-------------------------------------------------------------- PARALELLISME MAXIMAL 1/3 PREPARATION DES VARIABLES ---------------------------------------------------------------------
#Liste contenant tous les chemins :
liste_chemins = []

#récupération de tous les couples de tâches reliées (ex : si A -> B alors on ajoute ["A", "B"] à la liste "taches_direct_reliees")
def Get_couple_path(systeme_tache): 
  taches_direct_reliees =[]
  for key, values in systeme_tache.dictPrec.items():
    for value in values:
        taches_direct_reliees.append([value.name, key.name])

  return taches_direct_reliees


#Récupération des plus grands chemins du graphe, en reliant plusieurs tâches directement reliées entre elle 
#exemple : si ["A", "B"] et ["B", "C"] alors nouveau chemin : ["A", "B", "C"]

def GetPath(liste, systeme_tache):
  #Variable de stockage des couples de chemins directement reliés
  global taches_direct_reliees 
  taches_direct_reliees = Get_couple_path(systeme_tache)

  #Enregistre si l'un des chemins a évolué (une variable a été rajouté dans l'un d'entre eux)
  change = False 
  liste_temporaire = [] 
  
  #On parcours les listes de chemins contenus dans la variable passée en argument 
  for chemin in liste: 
    #Puis pour chaque couple de tâche de la liste taches_direct_reliees :
    for i in range(0,len(taches_direct_reliees)):
      derniere_tache_du_chemin = chemin[-1]
      premiere_tache_du_chemin = chemin[0]

      #Pour chaque chemins on cherche si une des extrémités du chemin est directemement reliée à une autre tâche en vue de completer le chemin, 
      #ex :  on sait que "A" et "B" sont reliés, ainsi si on a un chemin ["X", "Y", "A"] on peut l'enrichir du "B" en dernière position

      if(derniere_tache_du_chemin == taches_direct_reliees[i][0]): 
        liste_temporaire.append(premiere_tache_du_chemin)
        liste_temporaire.append(derniere_tache_du_chemin)
        liste_temporaire.append(taches_direct_reliees[i][-1])
        change= True 

        #si le chemin construit est > que taches_direct_reliees alors on peut l'ajouter à notre liste de chemins
        if(len(chemin) > len(taches_direct_reliees[i])): 
          index = liste.index(chemin) 
          liste_chemins[index].append(taches_direct_reliees[i][-1])
        else:
          liste_chemins.append(liste_temporaire)
        
        liste_temporaire = []
  #tant que l'un des chemins à été agrandit on fait une récursion sur la fonction avec la nouvelle liste de chemins
  if(change==True):
    return GetPath(liste_chemins, systeme_tache)

  #une fois qu'aucun changement ne s'est produit, on supprime les chemins qui se repètent pour ne garder que les plus grands
  return delete_dupplicated_path(liste_chemins)


#Suppression des chemins intermédiaires qui se retrouvent dans d'autres chemins
#exemple : si l'on a [["A", "B"], ["A", "B", "C"]] on souhaite garder que la seconde liste
def delete_dupplicated_path(liste_chemins):
  already_here=False
  liste_unique = []
  for chemins in liste_chemins:
    for chemins_deja_inclus in liste_unique:
      #Si le chemin actuellement observé se trouve déjà intégralement dans un chemin déjà ajouté à la liste de chemins unique
      #Le test passe à True 
      already_here = set(chemins).issubset(chemins_deja_inclus)
      if(already_here==True):
        #Si le test passe à True alors on passe au chemin suivant
        break
    if(chemins not in liste_unique and already_here==False):
      #Si le chemin ne se trouve pas déjà dans un chemin alors on l'ajoute à la liste de chemins unique
      liste_unique.append(chemins)
  return liste_unique 


    #-------------------------------------------------------------- PARALELLISME MAXIMAL 2/3 DETERMINISME ---------------------------------------------------------------------
#Recherche des tâches qui sont parallèles (2 prochaines fonctions):

#Générer une liste avec tous les couples de tâches possible à partir des tâches déclarées dans le système

def identify_couple(liste):
  couple_tache = []
  for i in range(len(liste)):
    for tache_1 in liste[i]:
      for y in range(len(liste)):
        for tache_2 in liste[y]:
          
          couple_temp = [tache_1, tache_2]
          couple_temp_envers = [tache_2, tache_1]
          if(couple_temp in couple_tache or couple_temp_envers in couple_tache or tache_1 == tache_2):
            pass
          elif(couple_temp not in taches_direct_reliees and couple_temp_envers not in taches_direct_reliees):
            couple_tache.append([tache_1, tache_2])
  return couple_tache

#Suppression des couples de tâches qui se trouvent au sein d'un même chemin (et qui ont donc une relation de dépendance directe ou indirecte)
#puis rendu de la liste avec les couples de tâches qui sont parallèles

def get_para_task(systeme_tache):
  liste_traitee = identify_couple(GetPath(Get_couple_path(systeme_tache),systeme_tache))
  liste_chemins = GetPath(Get_couple_path(systeme_tache), systeme_tache)
  couple_to_test = []
  for couple in liste_traitee:
    tache1 = couple[0]
    tache2 = couple[1]
    chemins_tache1 = [tuple(chemin) for chemin in liste_chemins if tache1 in chemin]
    chemins_tache2 = [tuple(chemin) for chemin in liste_chemins if tache2 in chemin]
    if len(set(chemins_tache1).intersection(set(chemins_tache2))) == 0 and couple not in couple_to_test:
      couple_to_test.append(couple)
  return couple_to_test


#---Verification determinisme (2 prochaines fonctions):
#Vérification du déterminisme 
#Vérification des conditions de Bernstein pour les couples de tâches isolées 
def interference(couple_tache, systeme_tache):
  #Creation d'un dictionnaire contenant pour chaque tâches déclarées son domaine de lecture et d'écriture
  domaine_lecture = {}
  domaine_ecriture = {}

  for tache in couple_tache:
    #récupération de l'objet Task nommé tache 
    for elem in systeme_tache.taches:
        if(elem.name == tache):
          tache = elem

    domaine_lecture[tache.name] = tache.reads
    domaine_ecriture[tache.name] = tache.writes

  tache_1 = couple_tache[0]
  tache_2 = couple_tache[1]
  interferentes = True
  
  #Création de variables qui continnent les variables d'écriture ou de lecture de chacune des tâches du couple
  tache_1_ecrit =[tuple(elem) for elem in domaine_ecriture[tache_1]]
  tache_1_lect = [tuple(elem) for elem in domaine_lecture[tache_1]]
  tache_2_ecrit =[tuple(elem) for elem in domaine_ecriture[tache_2]]
  tache_2_lect = [tuple(elem) for elem in domaine_lecture[tache_2]]

  #Si les tâches respectent une des trois conditions de Bernstein alors on passe interferentes à True
  #Les conditions sont réalisées par des comparaisons entre les variables précédentes et des ensembles crées temporairement pour une comparaison plus rapide  
  if len(set(tache_1_lect).intersection(set(tache_2_ecrit))) ==0 and len(set(tache_2_lect).intersection(set(tache_1_ecrit))) ==0 and len(set(tache_1_ecrit).intersection(set(tache_2_ecrit)))==0 :
    interferentes = False

  return interferentes 

#Appel de la fonction précédente et selon son résultat affichage d'un message d'erreur ou non
def Bernstein_test(liste_couple_a_test, systeme_tache):
  #Pour chaque couple de tâches, appel de la fonction qui retourne un booléen selon le respect ou non respect des conditions de Bernstein 
  for couple in liste_couple_a_test:
    if(interference(couple, systeme_tache) == True):
      error_msg = "Certaines tâches parallèles sont interférentes, veuillez redéfinir le graphe correctement"
      return error_msg
    else:
      continue

#-------------------------------------------------------------- PARALELLISME MAXIMAL 3/3 L'ALGORITHME ---------------------------------------------------------------------

#Création de la matrice des chemins en créant une instance de liste de forme ["A", "B"] pour toutes les taches reliees par un chemin
def matriceChemins():
  couples = []
  #Parcours des chemins
  for chemin in liste_chemins:
      for i in range(len(chemin)-1):
      #tache i du chemin à partir de laquelle on va créer des couples de tache la contenant ainsi que les taches qui la suivent dasn les chemins où elle se trouve
          tache1 = chemin[i]
          #Parcours de toutes les tâches suivants la tâche1 dans le chemin en cours 
          for j in range(i+1, len(chemin)):
              tache2 = chemin[j]
              couples.append([tache1, tache2])
  return couples

#A partir de la matrice des chemins, conception de la liste d'adjacence
def GetlisteAdjacence(matrice_des_chemins, systeme_tache):
  taches_a_conserver = []
  #Pour chaque couple de tache présents dans la matrice des chemins, test des conditions de Bernstein 
  for couple in matrice_des_chemins:
    taches_interferentes = interference(couple, systeme_tache)
    if(taches_interferentes==False): 
      pass
    #si les taches ne respectent pas les conditions de Berstein, alors on les stocke dans une liste
    elif(taches_interferentes==True and couple not in taches_a_conserver): 
      taches_a_conserver.append(couple)
  #Construction de la liste d'adjacence sous forme d'un dictionnaire
  liste_adjacence = {}

  for elem in taches_a_conserver:
    if(elem[0] not in liste_adjacence):
      #Pour chaque tâche en position 0 des couples de la matrice des chemins on crée une clé de dictionnaire
      tache_1 = elem[0]
      liste_adjacence[tache_1] = []
      for i in range(len(taches_a_conserver)):
        #on ajoute ensuite les tâches en deuxième position des couples de la matrice des chemins dans la liste
        if(tache_1 != taches_a_conserver[i][0]):
          pass
        else:
          liste_adjacence[tache_1].append(taches_a_conserver[i][1])

  return liste_adjacence

#On va supprimer les redondances qui se trouvent dans notre système de tâche
def DeleteRedundancies(dict_liste_adjacence):
  redundancy = False
  arcs_redondants = []
  #Pour chaque instance du dictionnaire représentant la liste d'adjacence du système de tâches
  for nom_tache, liste_taches_liees in dict_liste_adjacence.items():
  #On regarde pour chaque liste, pour chaque taches si celle-ci se retrouve dans les liste d'adjacence des autres tâches présentent dans cette liste
    for tache_liee_1 in liste_taches_liees:
      #On ne compare pas la tâche avec elle même
      for tache_liee_x in liste_taches_liees: 
        if(tache_liee_1 == tache_liee_x): #on exclue la tache 1 pour pouvoir comparer seulement les taches restantes 
          pass
        else:
          #Si c'est le cas, alors on passe la variable redundancy à True
          if(tache_liee_x in dict_liste_adjacence.keys() and tache_liee_1 in dict_liste_adjacence[tache_liee_x]):
            redundancy = True
           #Si la tâche n'est pas présente dans l'une des listes d'adjacence des autres tâches de la liste, alors la liaison n'est pas redondante, 
           #arrêt de la boucle sur cette tâche
          else:
            redundancy = False
            pass 

      #Si à ce stade du programme redundancy est toujours True, l'une des tâches se retrouve dans la liste d'adjacence de 
      #toutes les autres tâches présentent dans cette liste d'adjacence   
      if(redundancy == True):
        #On ajoute la clé de la liste ainsi que la tâche qui était en observation à une liste 
        arcs_redondants.append([nom_tache,tache_liee_1])

    #On supprime les dépendances qui étaient créees pour chacune des redondances trouvées
    for couple_redondant in arcs_redondants:
      tache_1 = couple_redondant[0]
      tache_2 = couple_redondant[1]
      dict_liste_adjacence[tache_1].remove(tache_2)

    #On retourne la liste d'adjacence nettoyée de toute redondance
    return dict_liste_adjacence

#--------------------------------------------------------------------lancement du parallélisme maximal  ---------------------------------------------------------------------------

#A certains endroit de notre code il est plus aisé de travailler avec le nom des tâches
#et non pas l'objet Task lui même, ici il s'agit de transformer un nom de tâche en objet Task 
def getTaskObject(systeme_tache, nom_tache):
  for elem in systeme_tache.taches:
    if(elem.name == nom_tache):
      return elem

#Génère un dictionnaire avec les relations de précédences de toute les tâches suite à l'opération de parallélisation max, 
#Le dictionnaire remplace ensuite l'ancien des dépendances dans le système de tâche
def getParaMax(systeme_tache):
      global liste_adjacence_without_redundancies
      couple_a_test = get_para_task(systeme_tache)
      dict_precedences  = {}
      if(type(Bernstein_test(couple_a_test, systeme_tache)) == str):
          return Bernstein_test(couple_a_test, systeme_tache)
      else:
          matrice_chemins = matriceChemins()
          liste_adjacence = GetlisteAdjacence(matrice_chemins, systeme_tache)
          liste_adjacence_without_redundancies = DeleteRedundancies(liste_adjacence)
          
          for key, liste_taches in liste_adjacence_without_redundancies.items():
              for tache in liste_taches:
                  tache_obj = getTaskObject(systeme_tache, tache)
                  key_obj = getTaskObject(systeme_tache, key)
                  if(tache_obj not in dict_precedences.keys()):
                      #on créer un liste qui contiendra les taches précédentes de la tache 
                      dict_precedences[tache_obj] = []
                  dict_precedences[tache_obj].append(key_obj) #on ajoute la première tache précédente de la tache à partir des listes d'adjacences
      systeme_tache.dictPrec = dict_precedences
      systeme_tache.para_max == True


#Fonction d'affichage des dépendances suivant le parallélisme maximal d'un tâche indiquée

def getDependencies(systeme_tache, NomTache):
  liste_nom_tache = []
  #On exécute la fonction de para max si pour ce système de tâche cela n'a pas encore été effectué
  if(systeme_tache.para_max==False):
    getParaMax(systeme_tache)

  #Les taches sont sous forme d'objets Task peu équivoque ainsi on affiche les noms 
  for tache_obj in systeme_tache.dictPrec[NomTache]:
    liste_nom_tache.append(tache_obj.name)

  #on retourne la liste des dépendance sous leur nom 
  return liste_nom_tache
  
#-----------------------------------------------------------------------Affichage d'un graphe selon le para max- --------------------------------------------------------------------

def draw(systeme_tache):

  taches_formatees_dot = "{rankdir=TB ;" 
  for tache, taches_precedentes in liste_adjacence_without_redundancies.items():
    i=0
    taches_formatees_dot+= tache + '->'
    for elem in taches_precedentes:
      taches_formatees_dot+= elem

      if(i==len(taches_precedentes)-1):
        taches_formatees_dot+= ";" #ajout d'un ";" entre les successions de tâches
      else:
        taches_formatees_dot+="," #ajout d'une virgule entre chaque tâches successives
      i+=1

  taches_formatees_dot+="}" #fermeture par une accolade à la fin du parcours
  dot = graphviz.Source(f'digraph "Systeme de taches avec parallélisme maximal" {taches_formatees_dot}')
  return dot

